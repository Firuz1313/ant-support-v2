<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Проверка подключения HDMI кабеля к телевизору</title>
<style>
  /* Сброс и базовые стили для комфортного восприятия */
  html, body {
    margin: 0; padding: 0; height: 100%;
    background: #e8f0f8; /* Светлый, но ненавязчивый фон для комфорта глаз */
    font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    color: #222;
    user-select: none;
    overflow: hidden;
  }
  #container {
    position: relative;
    width: 100vw; height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  canvas {
    border-radius: 12px;
    background: linear-gradient(180deg, #a4c0e8 0%, #7a9edc 100%);
    box-shadow: 0 8px 25px rgba(60, 80, 140, 0.3);
    display: block;
  }
  #instructions {
    position: absolute;
    bottom: 28px;
    width: 900px;
    text-align: center;
    color: #1a1a1a;
    font-weight: 700;
    font-size: 26px;
    text-shadow: 0 0 5px rgba(255 255 255 / 0.8);
    user-select: none;
    pointer-events: none;
  }
  #subtext {
    margin-top: 6px;
    font-weight: 500;
    font-size: 16px;
    color: #374253;
    text-shadow: 0 0 4px rgba(255 255 255 / 0.6);
  }
  #tv-screen-text {
    position: absolute;
    top: 50%;
    left: calc(50% + 200px);
    transform: translate(-50%, -50%);
    width: 380px;
    height: 220px;
    font-family: 'Courier New', Courier, monospace;
    font-size: 54px;
    font-weight: 700;
    color: #1a3cac;
    text-shadow:
      0 0 10px #1a3cac,
      0 0 25px #1a3cac;
    user-select: none;
    pointer-events: none;
    display: flex;
    justify-content: center;
    align-items: center;
    background: #e2e8f0cc;
    border-radius: 14px;
    box-shadow: 0 0 28px #a0b9f880 inset;
    opacity: 0;
    transition: opacity 0.9s ease;
  }
  #tv-screen-text.nosignal {
    color: #bc3b3b;
    text-shadow:
      0 0 12px #bc3b3b,
      0 0 30px #ff4d4d;
    background: #f9d7d7cc;
    box-shadow: 0 0 32px #f2707aee inset;
  }
  /* Пульт - 2D оверлей */
  #remote-overlay {
    position: absolute;
    bottom: 120px;
    right: 40px;
    width: 180px;
    height: 320px;
    background: linear-gradient(145deg, #444c5c, #353942);
    border-radius: 30px;
    box-shadow:
      0 4px 15px rgba(0,0,0,0.45),
      inset 0 0 8px #6c758d;
    display: none;
    user-select: none;
  }
  /* Кнопки пульта */
  .button {
    position: relative;
    width: 60px;
    height: 32px;
    margin: 12px auto;
    background: linear-gradient(145deg, #7f8ea3, #5e6779);
    border-radius: 8px;
    color: #eceff4;
    font-weight: 700;
    font-size: 14px;
    text-align: center;
    line-height: 32px;
    box-shadow:
      2px 2px 4px #4c5463,
      inset 1px 1px 5px #a8b0c3;
    cursor: pointer;
    user-select: none;
    transition: background 0.3s ease;
  }
  .button:active,
  .button.pressed {
    background: linear-gradient(145deg, #5e6779, #7f8ea3);
    box-shadow:
      inset 2px 2px 4px #4c5463,
      1px 1px 5px #a8b0c3;
  }
  #remote-instructions {
    color: #bcc6d4;
    font-size: 15px;
    text-align: center;
    padding: 10px 8px 0 8px;
    user-select: none;
  }
</style>
</head>
<body>
  <div id="container">
    <canvas id="canvas3d" width="900" height="600"></canvas>
    <div id="tv-screen-text"></div>
    <div id="instructions">
      <div id="main-text">Загрузка анимации...</div>
      <div id="subtext"></div>
    </div>
    <!-- Оверлей пульта, появляется на шаге 4 -->
    <div id="remote-overlay" aria-label="Пульт дистанционного управления">
      <div id="remote-instructions">Нажмите кнопку INPUT и выберите HDMI1 или HDMI2</div>
      <div class="button" id="btn-input">INPUT</div>
      <div class="button" id="btn-hdmi1">HDMI1</div>
      <div class="button" id="btn-hdmi2">HDMI2</div>
    </div>
  </div>

  <!-- Three.js и загрузчики -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/examples/js/loaders/GLTFLoader.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/examples/js/controls/OrbitControls.min.js"></script>
  <!-- GSAP для плавной анимации -->
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>
  <script>
    const canvas = document.getElementById('canvas3d');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setClearColor(0xa4c0e8);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.setSize(900, 600);

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(40, 900 / 600, 0.1, 50);
    camera.position.set(0, 1.6, 4.3);

    const controls = new THREE.OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.minDistance = 2.5;
    controls.maxDistance = 7;
    controls.maxPolarAngle = Math.PI / 2.3;

    // Свет
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 8, 4);
    directionalLight.castShadow = true;
    directionalLight.shadow.camera.left = -4;
    directionalLight.shadow.camera.right = 4;
    directionalLight.shadow.camera.top = 4;
    directionalLight.shadow.camera.bottom = -4;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    scene.add(directionalLight);

    // Пол для тени
    const floorGeo = new THREE.PlaneGeometry(15, 15);
    const floorMat = new THREE.ShadowMaterial({ opacity: 0.15 });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = 0;
    floor.receiveShadow = true;
    scene.add(floor);

    // Группы для объектов
    let tv, tuner, cable;

    // Тексты UI
    const mainText = document.getElementById('main-text');
    const subText = document.getElementById('subtext');
    const tvScreenText = document.getElementById('tv-screen-text');
    const remoteOverlay = document.getElementById('remote-overlay');
    const btnInput = document.getElementById('btn-input');
    const btnHdmi1 = document.getElementById('btn-hdmi1');
    const btnHdmi2 = document.getElementById('btn-hdmi2');

    // Флаги состояния
    let signalPresent = true;
    let animationTimeline;

    // Материал и геометрия для создания похожих моделей
    const createTVModel = () => {
      const tvGroup = new THREE.Group();

      // Корпус ТВ - чёрный матовый корпус
      const bodyGeometry = new THREE.BoxGeometry(3.8, 2.3, 0.3);
      const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x111318, roughness: 0.55, metalness: 0.25 });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.castShadow = true;
      body.receiveShadow = true;

      // Экран - слегка вдавлен, с эмиссией для подсветки
      const screenGeometry = new THREE.PlaneGeometry(3.6, 2.0);
      const screenMaterial = new THREE.MeshStandardMaterial({
        color: 0x001a34,
        emissive: 0x00183f,
        roughness: 0.15,
        metalness: 0.3,
      });
      const screen = new THREE.Mesh(screenGeometry, screenMaterial);
      screen.position.z = 0.165;

      tvGroup.add(body);
      tvGroup.add(screen);

      // HDMI вход - выступ на задней панели справа (смотреть со стороны камеры)
      const hdmiPortGeometry = new THREE.BoxGeometry(0.38, 0.15, 0.12);
      const hdmiPortMaterial = new THREE.MeshStandardMaterial({ color: 0x555e70, metalness: 0.6, roughness: 0.3 });
      const hdmiPort = new THREE.Mesh(hdmiPortGeometry, hdmiPortMaterial);
      hdmiPort.position.set(1.55, 0.65, -0.17);
      hdmiPort.castShadow = true;
      hdmiPort.receiveShadow = true;

      tvGroup.add(hdmiPort);

      // Сохраняем ссылку на экран и HDMI вход для анимации
      tvGroup.screen = screen;
      tvGroup.hdmiInput = hdmiPort;

      return tvGroup;
    };

    const createTunerModel = () => {
      const tunerGroup = new THREE.Group();

      // Корпус приставки - алюминиево-серый
      const bodyGeometry = new THREE.BoxGeometry(2.85, 0.72, 1.43);
      const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x2f3241, roughness: 0.3, metalness: 0.65 });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.castShadow = true;
      body.receiveShadow = true;

      // Лицевая панель с глянцем и кнопками
      const frontGeom = new THREE.PlaneGeometry(2.79, 0.62);
      const frontMat = new THREE.MeshStandardMaterial({
        color: 0x101826,
        emissive: 0x002041,
        roughness: 0.15,
        metalness: 0.8
      });
      const frontPanel = new THREE.Mesh(frontGeom, frontMat);
      frontPanel.position.z = 0.72;
      frontPanel.position.y = 0.015;

      // HDMI выход сзади слева
      const hdmiOutGeom = new THREE.BoxGeometry(0.33, 0.12, 0.11);
      const hdmiOutMat = new THREE.MeshStandardMaterial({ color: 0x5a667d, metalness: 0.85, roughness: 0.25 });
      const hdmiOut = new THREE.Mesh(hdmiOutGeom, hdmiOutMat);
      hdmiOut.position.set(-1.18, 0.35, -0.62);
      hdmiOut.castShadow = true;
      hdmiOut.receiveShadow = true;

      tunerGroup.add(body);
      tunerGroup.add(frontPanel);
      tunerGroup.add(hdmiOut);

      tunerGroup.hdmiOutput = hdmiOut;

      return tunerGroup;
    };

    const createHDMICableModel = () => {
      const cableGroup = new THREE.Group();

      // Кабель — цилиндр длиной, чёрный матовый
      const cableLength = 2.5;
      const cableRadius = 0.04;
      const cableGeo = new THREE.CylinderGeometry(cableRadius, cableRadius, cableLength, 20);
      const cableMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.9, metalness: 0.05 });
      const cable = new THREE.Mesh(cableGeo, cableMat);
      cable.rotation.z = Math.PI / 2;
      cable.position.set(0, 0, 0);
      cable.castShadow = true;
      cable.receiveShadow = true;
      cableGroup.add(cable);

      // Разъемы по концам — детализированные, металлик с индикатором
      const plugGeom = new THREE.BoxGeometry(0.18, 0.06, 0.13);
      const plugMat = new THREE.MeshStandardMaterial({ color: 0x2c3544, roughness: 0.28, metalness: 0.8 });

      const plugStart = new THREE.Mesh(plugGeom, plugMat);
      plugStart.position.set(-cableLength / 2, 0, 0);
      plugStart.castShadow = true;
      cableGroup.add(plugStart);

      const plugEnd = new THREE.Mesh(plugGeom, plugMat);
      plugEnd.position.set(cableLength / 2, 0, 0);
      plugEnd.castShadow = true;
      cableGroup.add(plugEnd);

      // Светящиеся синие индикаторы на разъемах
      const ledGeom = new THREE.BoxGeometry(0.065, 0.022, 0.015);
      const ledMat = new THREE.MeshStandardMaterial({
        color: 0x3ba1ff,
        emissive: 0x3ba1ff,
        emissiveIntensity: 0.8
      });

      const ledStart = new THREE.Mesh(ledGeom, ledMat);
      ledStart.position.set(-cableLength / 2 - 0.06, 0.003, 0.05);
      cableGroup.add(ledStart);

      const ledEnd = new THREE.Mesh(ledGeom, ledMat);
      ledEnd.position.set(cableLength / 2 + 0.06, 0.003, 0.05);
      cableGroup.add(ledEnd);

      cableGroup.plugStart = plugStart;
      cableGroup.plugEnd = plugEnd;

      return cableGroup;
    };

    // Создаем объекты и размещаем в сцене
    tv = createTVModel();
    tuner = createTunerModel();
    cable = createHDMICableModel();

    scene.add(tv);
    scene.add(tuner);
    scene.add(cable);

    // Позиционируем ТВ и приставку рядом слева направо
    tv.position.set(1.2, 0, 0);
    tuner.position.set(-1.35, 0, 0);

    // Кабель сложен и лежит слева под тюнером (отсоединен)
    cable.position.set(-2.8, 0.4, 0);
    cable.rotation.set(0, 0, 0);

    // Функция получения позиции в мировых координатах
    function getWorldPos(obj) {
      const pos = new THREE.Vector3();
      obj.getWorldPosition(pos);
      return pos;
    }

    // Отображение текста на экране ТВ
    function showTvScreenText(text, isError = false) {
      tvScreenText.textContent = text;
      if (isError) {
        tvScreenText.classList.add("nosignal");
      } else {
        tvScreenText.classList.remove("nosignal");
      }
      tvScreenText.style.opacity = "1";
    }
    function hideTvScreenText() {
      tvScreenText.style.opacity = "0";
      setTimeout(() => {
        tvScreenText.textContent = "";
        tvScreenText.classList.remove("nosignal");
      }, 1000);
    }

    // Основной сценарий анимации
    function startAnimation() {
      signalPresent = true;
      mainText.textContent = "Проверьте, правильно ли подключён HDMI-кабель.";
      subText.textContent = "";

      hideTvScreenText();
      remoteOverlay.style.display = "none";
      controls.enabled = false;

      cable.position.set(-2.8, 0.4, 0);
      cable.rotation.set(0, 0, 0);

      const tunerHdmiPos = getWorldPos(tuner.hdmiOutput);
      const tvHdmiPos = getWorldPos(tv.hdmiInput);

      if (animationTimeline) animationTimeline.kill();

      animationTimeline = gsap.timeline({
        defaults: { ease: "power1.inOut" },
        onComplete: () => {
          controls.enabled = true;
          if (signalPresent) {
            showTvScreenText("HDMI");
            mainText.textContent = "Если всё подключено правильно — сигнал появится автоматически.";
            subText.textContent = "";
            tv.screen.material.emissive.setHex(0x2255ff);
            tv.screen.material.emissiveIntensity = 0.7;
          } else {
            showTvScreenText("Нет сигнала", true);
            mainText.textContent = "Убедитесь, что на ТВ выбран правильный HDMI-вход.";
            subText.textContent = "Используйте пульт для выбора HDMI1 или HDMI2.";
            tv.screen.material.emissive.setHex(0xdb4444);
            tv.screen.material.emissiveIntensity = 0.7;
            remoteOverlay.style.display = "block";
          }
        }
      });

      // Шаг 1: вводная с текстом - 2 сек
      animationTimeline.to({}, { duration: 2 });

      // Шаг 2: кабель движется к приставке (plugStart к выходу приставки)
      animationTimeline.to(cable.position, {
        duration: 3.5,
        x: tunerHdmiPos.x,
        y: tunerHdmiPos.y + 0.017,
        z: tunerHdmiPos.z,
      }, ">");

      animationTimeline.to(cable.rotation, { y: Math.PI / 10, duration: 0.6 }, "<");

      // Шаг 3: кабель движется к телевизору (plugEnd к входу ТВ)
      animationTimeline.to(cable.position, {
        duration: 3.5,
        x: tvHdmiPos.x,
        y: tvHdmiPos.y + 0.017,
        z: tvHdmiPos.z,
      });

      animationTimeline.to(cable.rotation, { y: Math.PI / 12, duration: 0.7 }, "<");

      animationTimeline.to({}, { duration: 0.8 });

      // Финальный шаг - показать надпись на ТВ
      animationTimeline.call(() => {
        if (signalPresent) {
          showTvScreenText("HDMI");
          mainText.textContent = "Если всё подключено правильно — сигнал появится автоматически.";
          subText.textContent = "";
          tv.screen.material.emissive.setHex(0x2255ff);
          tv.screen.material.emissiveIntensity = 0.7;
          remoteOverlay.style.display = "none";
        } else {
          showTvScreenText("Нет сигнала", true);
          mainText.textContent = "Убедитесь, что на ТВ выбран правильный HDMI-вход.";
          subText.textContent = "Используйте пульт для выбора HDMI1 или HDMI2.";
          tv.screen.material.emissive.setHex(0xdb4444);
          tv.screen.material.emissiveIntensity = 0.7;
          remoteOverlay.style.display = "block";
        }
      });

      animationTimeline.to({}, { duration: 2 });
    }

    // Функция сброса состояния
    function resetAnimation() {
      if (animationTimeline) animationTimeline.kill();
      cable.position.set(-2.8, 0.4, 0);
      cable.rotation.set(0, 0, 0);
      hideTvScreenText();
      mainText.textContent = "Проверьте, правильно ли подключён HDMI-кабель.";
      subText.textContent = "";
      remoteOverlay.style.display = "none";
      signalPresent = true;
      controls.enabled = true;
      tv.screen.material.emissive.setHex(0x000000);
      tv.screen.material.emissiveIntensity = 0;
    }

    // Обработка пульта (эмуляция взаимодействия, подсвечиваем кнопки)
    btnInput.addEventListener("click", () => {
      btnInput.classList.add("pressed");
      setTimeout(() => btnInput.classList.remove("pressed"), 250);
    });

    btnHdmi1.addEventListener("click", () => {
      btnHdmi1.classList.add("pressed");
      btnHdmi2.classList.remove("pressed");
      setTimeout(() => btnHdmi1.classList.remove("pressed"), 350);
      signalPresent = true;
      showTvScreenText("HDMI");
      mainText.textContent = "Если всё подключено правильно — сигнал появится автоматически.";
      subText.textContent = "";
      remoteOverlay.style.display = "none";
      tv.screen.material.emissive.setHex(0x2255ff);
      tv.screen.material.emissiveIntensity = 0.7;
    });

    btnHdmi2.addEventListener("click", () => {
      btnHdmi2.classList.add("pressed");
      btnHdmi1.classList.remove("pressed");
      setTimeout(() => btnHdmi2.classList.remove("pressed"), 350);
      signalPresent = true;
      showTvScreenText("HDMI");
      mainText.textContent = "Если всё подключено правильно — сигнал появится автоматически.";
      subText.textContent = "";
      remoteOverlay.style.display = "none";
      tv.screen.material.emissive.setHex(0x2255ff);
      tv.screen.material.emissiveIntensity = 0.7;
    });

    // Клавиша R для сброса (для удобства тестирования)
    window.addEventListener("keydown", e => {
      if (e.key === "r" || e.key === "R") resetAnimation();
    });

    // Инициализация - первая сцена и запуск анимации
    function init() {
      resetAnimation();
      // Отобразим инструкции для запуска с пробелом
      mainText.textContent = "Нажмите ПРОБЕЛ для начала анимации";
      subText.textContent = "";

      // Запуск анимации по пробелу
      function onSpace(e) {
        if (e.code === "Space" && !animationTimeline) {
          startAnimation();
          window.removeEventListener("keydown", onSpace);
        }
      }
      window.addEventListener("keydown", onSpace);
    }

    // Рендеринг и анимация сцены (орбитальные controls)
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    init();
    animate();
  </script>
</body>
</html> 