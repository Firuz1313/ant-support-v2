<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>HDMI Cable Connection Animation</title>
<style>
  html, body {
    margin: 0; padding: 0; height: 100%;
    background: #d6e3f0; /* Soft blue-gray background - eye friendly */
    font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    color: #222;
    overflow: hidden;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    user-select: none;
  }
  #container {
    position: relative;
    width: 100vw; height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  canvas {
    border-radius: 12px;
    background: linear-gradient(180deg, #a4c0e8 0%, #7a9edc 100%);
    box-shadow: 0 8px 25px rgba(60, 80, 140, 0.3);
    display: block;
  }
  #instruction {
    position: absolute;
    bottom: 28px;
    width: 900px;
    text-align: center;
    color: #1a1a1a;
    font-weight: 700;
    font-size: 26px;
    text-shadow: 0 0 5px rgba(255 255 255 / 0.8);
    user-select: none;
    pointer-events: none;
  }
  #instruction-sub {
    margin-top: 6px;
    font-weight: 500;
    font-size: 16px;
    color: #374253;
    text-shadow: 0 0 4px rgba(255 255 255 / 0.6);
  }
  #tv-screen-overlay {
    position: absolute;
    top: 50%;
    left: calc(50% + 200px);
    transform: translate(-50%, -50%);
    width: 380px;
    height: 220px;
    font-family: 'Courier New', Courier, monospace;
    font-size: 54px;
    font-weight: 700;
    color: #1a3cac;
    text-shadow:
      0 0 10px #1a3cac,
      0 0 25px #1a3cac;
    user-select: none;
    pointer-events: none;
    display: flex;
    justify-content: center;
    align-items: center;
    background: #e2e8f0cc;
    border-radius: 14px;
    box-shadow: 0 0 28px #a0b9f880 inset;
    opacity: 0;
    transition: opacity 0.9s ease;
  }
  #tv-screen-overlay.no-signal {
    color: #bc3b3b;
    text-shadow:
      0 0 12px #bc3b3b,
      0 0 30px #ff4d4d;
    background: #f9d7d7cc;
    box-shadow: 0 0 32px #f2707aee inset;
  }
  #remote-ui {
    position: absolute;
    bottom: 120px;
    right: 40px;
    width: 180px;
    height: 320px;
    background: linear-gradient(145deg, #444c5c, #353942);
    border-radius: 30px;
    box-shadow:
      0 4px 15px rgba(0,0,0,0.45),
      inset 0 0 8px #6c758d;
    display: none;
    user-select: none;
  }
  #remote-instructions {
    color: #bcc6d4;
    font-size: 15px;
    text-align: center;
    padding: 10px 8px 0 8px;
    user-select: none;
  }
  .remote-button {
    position: relative;
    width: 60px;
    height: 32px;
    margin: 12px auto;
    background: linear-gradient(145deg, #7f8ea3, #5e6779);
    border-radius: 8px;
    color: #eceff4;
    font-weight: 700;
    font-size: 14px;
    text-align: center;
    line-height: 32px;
    box-shadow:
      2px 2px 4px #4c5463,
      inset 1px 1px 5px #a8b0c3;
    cursor: pointer;
    user-select: none;
    transition: background 0.3s ease;
  }
  .remote-button:active,
  .remote-button.pressed {
    background: linear-gradient(145deg, #5e6779, #7f8ea3);
    box-shadow:
      inset 2px 2px 4px #4c5463,
      1px 1px 5px #a8b0c3;
  }
  #debug {
    position: absolute;
    top: 10px;
    left: 10px;
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 10px;
    border-radius: 5px;
    font-size: 12px;
    max-width: 300px;
  }
</style>
</head>
<body>
  <div id="container">
    <canvas id="canvas3d" width="900" height="600" aria-label="3D animation of HDMI cable connection"></canvas>
    <div id="tv-screen-overlay" aria-live="polite"></div>
    <div id="instruction" aria-live="polite" role="region" aria-atomic="true">
      <div id="instruction-main">Loading animation...</div>
      <div id="instruction-sub"></div>
    </div>
    <div id="remote-ui" role="region" aria-label="TV remote control simulation">
      <div id="remote-instructions">Press INPUT then choose HDMI1 or HDMI2</div>
      <div class="remote-button" id="btn-input" role="button" tabindex="0" aria-pressed="false" aria-label="INPUT button">INPUT</div>
      <div class="remote-button" id="btn-hdmi1" role="button" tabindex="0" aria-pressed="false" aria-label="Select HDMI1 input">HDMI1</div>
      <div class="remote-button" id="btn-hdmi2" role="button" tabindex="0" aria-pressed="false" aria-label="Select HDMI2 input">HDMI2</div>
    </div>
    <div id="debug">Debug...</div>
  </div>

  <!-- Three.js and GSAP -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>
  
  <script>
    const debug = document.getElementById('debug');
    const instructionMain = document.getElementById('instruction-main');
    const instructionSub = document.getElementById('instruction-sub');
    const tvScreenOverlay = document.getElementById('tv-screen-overlay');
    const remoteUI = document.getElementById('remote-ui');
    const btnInput = document.getElementById('btn-input');
    const btnHdmi1 = document.getElementById('btn-hdmi1');
    const btnHdmi2 = document.getElementById('btn-hdmi2');

    function log(message) {
      debug.textContent = message;
      console.log(message);
    }

    try {
      log("Initializing Three.js...");
      
      const canvas = document.getElementById('canvas3d');
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(900, 600);
      renderer.setClearColor(0xa6bdd9);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      const scene = new THREE.Scene();

      const camera = new THREE.PerspectiveCamera(40, 900/600, 0.1, 50);
      camera.position.set(0, 1.65, 4.4);

      const controls = new OrbitControls(camera, canvas);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.minDistance = 3;
      controls.maxDistance = 6;
      controls.maxPolarAngle = Math.PI / 2.3;

      log("Three.js initialized");

      // Lights
      scene.add(new THREE.AmbientLight(0xffffff, 0.38));

      const dirLight = new THREE.DirectionalLight(0xffffff, 1.1);
      dirLight.position.set(4.5, 7.5, 4);
      dirLight.castShadow = true;
      dirLight.shadow.camera.left = -5;
      dirLight.shadow.camera.right = 5;
      dirLight.shadow.camera.top = 5;
      dirLight.shadow.camera.bottom = -5;
      dirLight.shadow.mapSize.width = 2048;
      dirLight.shadow.mapSize.height = 2048;
      scene.add(dirLight);

      // Floor - shadow receiver
      const floorGeo = new THREE.PlaneGeometry(20, 20);
      const floorMat = new THREE.ShadowMaterial({ opacity: 0.22 });
      const floor = new THREE.Mesh(floorGeo, floorMat);
      floor.rotation.x = -Math.PI/2;
      floor.position.y = 0;
      floor.receiveShadow = true;
      scene.add(floor);

      log("Creating models...");

      // Create models (TV, tuner, HDMI cable)
      // TV model
      function createTV() {
        const tv = new THREE.Group();

        const bodyGeo = new THREE.BoxGeometry(3.9, 2.35, 0.35);
        const bodyMat = new THREE.MeshStandardMaterial({color: 0x121c25, roughness: 0.6, metalness: 0.25});

        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.castShadow = true;
        body.receiveShadow = true;

        const screenGeo = new THREE.PlaneGeometry(3.75, 2.05);
        const screenMat = new THREE.MeshStandardMaterial({
          color: 0x001b35,
          emissive: 0x002150,
          roughness: 0.2,
          metalness: 0.25,
        });
        const screen = new THREE.Mesh(screenGeo, screenMat);
        screen.position.z = 0.18;

        // HDMI port behind right side (from front)
        const hdmiGeo = new THREE.BoxGeometry(0.38, 0.16, 0.13);
        const hdmiMat = new THREE.MeshStandardMaterial({color: 0x5b6473, roughness: 0.3, metalness: 0.7});

        const hdmiPort = new THREE.Mesh(hdmiGeo, hdmiMat);
        hdmiPort.position.set(1.58, 0.64, -0.21);
        hdmiPort.castShadow = true;
        hdmiPort.receiveShadow = true;

        tv.add(body, screen, hdmiPort);

        tv.screen = screen;
        tv.hdmiPort = hdmiPort;

        return tv;
      }

      // Tuner model
      function createTuner() {
        const tuner = new THREE.Group();

        const bodyGeo = new THREE.BoxGeometry(2.85, 0.75, 1.44);
        const bodyMat = new THREE.MeshStandardMaterial({ color: 0x323a51, roughness: 0.24, metalness: 0.8 }); 
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.castShadow = true;
        body.receiveShadow = true;

        // Front glossy panel
        const frontGeo = new THREE.PlaneGeometry(2.82, 0.62);
        const frontMat = new THREE.MeshStandardMaterial({ color: 0x071025, emissive: 0x00132f, roughness: 0.12, metalness: 0.85 });
        const frontPanel = new THREE.Mesh(frontGeo, frontMat);
        frontPanel.position.z = 0.73;
        frontPanel.position.y = 0.015;

        // HDMI output port - back left
        const hdmiOutGeo = new THREE.BoxGeometry(0.33, 0.12, 0.11);
        const hdmiOutMat = new THREE.MeshStandardMaterial({ color: 0x5a647e, roughness: 0.21, metalness: 0.73 });
        const hdmiOut = new THREE.Mesh(hdmiOutGeo, hdmiOutMat);
        hdmiOut.position.set(-1.25, 0.37, -0.62);
        hdmiOut.castShadow = true;
        hdmiOut.receiveShadow = true;

        tuner.add(body, frontPanel, hdmiOut);

        tuner.hdmiOut = hdmiOut;

        return tuner;
      }

      // HDMI cable model
      function createCable() {
        const cable = new THREE.Group();

        const length = 2.55;
        const radius = 0.045;
        const cableGeo = new THREE.CylinderGeometry(radius, radius, length, 20);
        const cableMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.92, metalness: 0.07 });
        const cableMesh = new THREE.Mesh(cableGeo, cableMat);
        cableMesh.rotation.z = Math.PI / 2;
        cableMesh.castShadow = true;
        cableMesh.receiveShadow = true;

        // Plugs on both ends
        const plugGeo = new THREE.BoxGeometry(0.18, 0.065, 0.13);
        const plugMat = new THREE.MeshStandardMaterial({ color: 0x2f3547, roughness: 0.27, metalness: 0.88 });

        const plugStart = new THREE.Mesh(plugGeo, plugMat);
        plugStart.position.set(-length / 2, 0, 0);
        plugStart.castShadow = true;

        const plugEnd = new THREE.Mesh(plugGeo, plugMat);
        plugEnd.position.set(length / 2, 0, 0);
        plugEnd.castShadow = true;

        // Blue emissive LED indicators on plugs
        const ledGeo = new THREE.BoxGeometry(0.065, 0.02, 0.015);
        const ledMat = new THREE.MeshStandardMaterial({
          color: 0x3a9bff,
          emissive: 0x3a9bff,
          emissiveIntensity: 0.85,
        });

        const ledStart = new THREE.Mesh(ledGeo, ledMat);
        ledStart.position.set(-length / 2 - 0.06, 0.003, 0.055);

        const ledEnd = new THREE.Mesh(ledGeo, ledMat);
        ledEnd.position.set(length / 2 + 0.06, 0.003, 0.055);

        cable.add(cableMesh, plugStart, plugEnd, ledStart, ledEnd);

        cable.plugStart = plugStart;
        cable.plugEnd = plugEnd;

        return cable;
      }

      // Add objects to scene
      const tv = createTV();
      const tuner = createTuner();
      const cable = createCable();

      tv.position.set(1.15, 0, 0);
      tuner.position.set(-1.35, 0, 0);
      cable.position.set(-2.8, 0.38, 0);
      cable.rotation.set(0, 0, 0);

      scene.add(tv, tuner, cable);

      log("Models created and positioned");

      // Helper to get world position
      function worldPos(obj) {
        const pos = new THREE.Vector3();
        obj.getWorldPosition(pos);
        return pos;
      }

      let signalDetected = true;
      let timeline;

      // Show text on TV screen overlay
      function showTvScreen(text, error = false) {
        tvScreenOverlay.textContent = text;
        if(error) {
          tvScreenOverlay.classList.add("no-signal");
        } else {
          tvScreenOverlay.classList.remove("no-signal");
        }
        tvScreenOverlay.style.opacity = "1";
      }
      
      function hideTvScreen() {
        tvScreenOverlay.style.opacity = "0";
        setTimeout(() => {
          tvScreenOverlay.textContent = "";
          tvScreenOverlay.classList.remove("no-signal");
        }, 900);
      }

      // Reset scene
      function resetScene() {
        if(timeline) timeline.kill();
        cable.position.set(-2.8, 0.38, 0);
        cable.rotation.set(0, 0, 0);
        hideTvScreen();
        instructionMain.textContent = "Check if the HDMI cable is properly connected.";
        instructionSub.textContent = "";
        remoteUI.style.display = "none";
        signalDetected = true;
        controls.enabled = true;
        tv.screen.material.emissive.setHex(0x000000);
        tv.screen.material.emissiveIntensity = 0;
      }

      // Main animation flow
      function runAnimation() {
        log("Starting animation...");
        signalDetected = true;
        instructionMain.textContent = "Check if the HDMI cable is properly connected.";
        instructionSub.textContent = "";

        hideTvScreen();
        remoteUI.style.display = "none";
        controls.enabled = false;

        const tunerPortPos = worldPos(tuner.hdmiOut);
        const tvPortPos = worldPos(tv.hdmiPort);

        if(timeline) timeline.kill();

        timeline = gsap.timeline({
          defaults: {ease: "power1.inOut"},
          onComplete: () => {
            log("Animation completed");
            controls.enabled = true;
            if(signalDetected) {
              showTvScreen("HDMI");
              instructionMain.textContent = "If the connection is correct, the signal will appear automatically.";
              instructionSub.textContent = "";
              tv.screen.material.emissive.setHex(0x3366ff);
              tv.screen.material.emissiveIntensity = 0.7;
              remoteUI.style.display = "none";
            } else {
              showTvScreen("No Signal", true);
              instructionMain.textContent = "Make sure the TV is set to the correct HDMI input.";
              instructionSub.textContent = "Use the remote to select HDMI1 or HDMI2.";
              tv.screen.material.emissive.setHex(0xcc4444);
              tv.screen.material.emissiveIntensity = 0.7;
              remoteUI.style.display = "block";
            }
          }
        });

        // Step 1: intro delay
        timeline.to({}, {duration: 2});

        // Step 2: cable moves to tuner
        timeline.to(cable.position, {
          duration: 3.5,
          x: tunerPortPos.x,
          y: tunerPortPos.y + 0.015,
          z: tunerPortPos.z,
        }, ">");

        timeline.to(cable.rotation, { y: Math.PI / 12, duration: 0.6 }, "<");

        // Step 3: cable moves to TV
        timeline.to(cable.position, {
          duration: 3.8,
          x: tvPortPos.x,
          y: tvPortPos.y + 0.015,
          z: tvPortPos.z,
        });

        timeline.to(cable.rotation, { y: Math.PI / 15, duration: 0.7 }, "<");

        timeline.to({}, {duration: 1});

        timeline.call(() => {
          if(signalDetected) {
            showTvScreen("HDMI");
            instructionMain.textContent = "If the connection is correct, the signal will appear automatically.";
            instructionSub.textContent = "";
            remoteUI.style.display = "none";
            tv.screen.material.emissive.setHex(0x3366ff);
            tv.screen.material.emissiveIntensity = 0.7;
          } else {
            showTvScreen("No Signal", true);
            instructionMain.textContent = "Make sure the TV is set to the correct HDMI input.";
            instructionSub.textContent = "Use the remote to select HDMI1 or HDMI2.";
            remoteUI.style.display = "block";
            tv.screen.material.emissive.setHex(0xcc4444);
            tv.screen.material.emissiveIntensity = 0.7;
          }
        });

        timeline.to({}, {duration: 2});
      }

      // Remote control button handlers
      btnInput.addEventListener("click", () => {
        btnInput.classList.add("pressed");
        btnInput.setAttribute("aria-pressed", "true");
        setTimeout(() => {
          btnInput.classList.remove("pressed");
          btnInput.setAttribute("aria-pressed", "false");
        }, 250);
      });
      
      btnHdmi1.addEventListener("click", () => {
        btnHdmi1.classList.add("pressed");
        btnHdmi1.setAttribute("aria-pressed", "true");
        btnHdmi2.classList.remove("pressed");
        btnHdmi2.setAttribute("aria-pressed", "false");
        setTimeout(() => btnHdmi1.classList.remove("pressed"), 350);
        // Simulate correct signal received
        signalDetected = true;
        showTvScreen("HDMI");
        instructionMain.textContent = "If the connection is correct, the signal will appear automatically.";
        instructionSub.textContent = "";
        remoteUI.style.display = "none";
        tv.screen.material.emissive.setHex(0x3366ff);
        tv.screen.material.emissiveIntensity = 0.7;
      });
      
      btnHdmi2.addEventListener("click", () => {
        btnHdmi2.classList.add("pressed");
        btnHdmi2.setAttribute("aria-pressed", "true");
        btnHdmi1.classList.remove("pressed");
        btnHdmi1.setAttribute("aria-pressed", "false");
        setTimeout(() => btnHdmi2.classList.remove("pressed"), 350);
        signalDetected = true;
        showTvScreen("HDMI");
        instructionMain.textContent = "If the connection is correct, the signal will appear automatically.";
        instructionSub.textContent = "";
        remoteUI.style.display = "none";
        tv.screen.material.emissive.setHex(0x3366ff);
        tv.screen.material.emissiveIntensity = 0.7;
      });

      // Keyboard shortcut for resetting animation: Press R
      window.addEventListener('keydown', (e) => {
        if(e.key.toLowerCase() === 'r') {
          resetScene();
        }
        // Start animation on space if not running
        if(e.code === 'Space' && (!timeline || !timeline.isActive())) {
          runAnimation();
        }
      });

      // Initial instructions
      function init() {
        resetScene();
        instructionMain.textContent = "Press SPACE to start the HDMI connection animation";
        instructionSub.textContent = "(Press R to reset at any time)";
        log("Ready to start. Press SPACE");
      }

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }

      init();
      animate();
      
    } catch (error) {
      log("Error: " + error.message);
      console.error("Error:", error);
    }
  </script>
</body>
</html> 